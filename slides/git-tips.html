<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Git Tips - Askeing</title>

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="../reveal-js/css/reveal.min.css">
		<link rel="stylesheet" href="../reveal-js/css/theme/night.css" id="theme">
		<style>
			code {color: Chartreuse;}
		</style>
	</head>

	<body>

		<div class="reveal">

			<div class="slides">

				<section>
					<section>
						<h1>Git Tips</h1>
						<br/>
						<p>Askeing Yen &lt;fyen@mozilla.com&gt;</p>
						<aside class="notes">
							Oh hey, these are some notes. They'll be hidden in your presentation, but you can see them if you open the speaker notes window (hit 's' on your keyboard).
						</aside>
					</section>
					<section>
						<h1>Goal</h1>
						<ul>
							<li>Speed</li>
							<li>Simple</li>
							<li>Non-linear development</li>
							<li>Distributed</li>
						</ul>
					</section>
				</section>

				<section>
					<h2>States</h2>
					<p>modified, staged, and committed</p>
					<img src="http://git-scm.com/figures/18333fig0106-tn.png">
					<p>(from http://git-scm.com/)</p>
				</section>

				<section>
					<section>
						<h1>Config</h1>
					</section>
					<section>
						<h2>Basic</h2>
						<ul>
							<li><code>git config --list</code></li>
							<li><code>git config --global user.name "foo"</code></li>
							<li><code>git config --global user.email "foo@mozilla.com"</code></li>
						</ul>
						<aside class="notes">
							The --list will list all config.<br/>
							First, we should setup the username and email for git.
						</aside>
					</section>
					<section>
						<h2>Customizing</h2>
						<ul>
							<li><code>git config --global core.editor vim</code></li>
							<li><code>git config --global merge.tool vimdiff</code></li>
							<li><code>git config --global core.pager ''</code></li>
							<li><code>git config --global core.whitespace cr-at-eol</code>
								<ul>
									<li><span>stop viewing those <span style="color: Red;">^M</span> symbols at the end of lines created by Windows</span></li>
								</ul>
							</li>
						</ul>
						<aside class="notes">
							The default pager is "less", and "" means no pager.<br/>
							Latest one will stop viewing the ^M which created by Windows.
						</aside>
					</section>
					<section>
						<h2>Config files</h2>
						<ul>
							<li>/etc/gitconfig
								<ul>
									<li>--system</li>
								</ul>
							</li>
							<li>~/.gitconfig
								<ul>
									<li>--global</li>
								</ul>
							</li>
							<li>{REPO}/.git/config
								<ul>
									<li>--local</li>
								</ul>
							</li>
						</ul>
						<aside class="notes">
							Read config: system &gt; global &gt; local.<br/>
							The priority: system &lt; global &lt; local.
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h1>Alias</h1>
					</section>
					<section>
						<h2>Commands</h2>
						<ul>
							<li><code>git config --global alias.co checkout</code></li>
							<li><code>git config --global alias.br branch</code></li>
							<li><code>git config --global alias.ci commit</code></li>
							<li><code>git config --global alias.st status</code></li>
						</ul>
						<aside class="notes">
							We can setup our own alias for each git command.
						</aside>
					</section>
					<section>
						<h2>Creating commands</h2>
						<ul>
							<li><code>git config --global alias.unstage 'reset HEAD --'</code></li>
							<li><code>git config --global alias.last 'log -1 HEAD'</code></li>
							<li><code style="font-size: 90%">git config --global alias.root 'rev-parse --show-toplevel'</code></li>
						</ul>
						<aside class="notes">
							And we can create our own commands.<br/>
							By the way, the combination of "cd" and "git root" will very useful.<br/>
							ex: "cd `git root`"
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h1>History</h1>
					</section>
					<section>
						<h2>Commit logs</h2>
						<ul>
							<li><code>git log -p</code></li>
							<li><code>git log -S &lt;string&gt;</code></li>
							<li><code>git log --graph</code></li>
						</ul>
						<aside class="notes">
							The -p, --patch will show patches of each commit.<br/>
							And -S will look for differences that introduce or remove an instance of string.<br/>
							The --graph will draw the commit history.
						</aside>
					</section>
					<section>
						<h2>Blame</h2>
						<ul>
							<li><code>git blame -L &lt;n&gt;,&lt;m&gt; &lt;file&gt;</code></li>
							<li><code>git blame -C &lt;file&gt;</code></li>
						</ul>
						<aside class="notes">
							The -L will only annotate the given line range. (number, /regex/, +offset or -offset for &lt;m&gt;)<br/>
							The -C detect lines moved or copied from other files.
						</aside>
					</section>
					<section>
						<h2>Binary search</h2>
						<ul>
							<li><code>git bisect start</code></li>
							<li><code>git bisect bad</code></li>
							<li><code>git bisect good &lt;commit&gt;</code></li>
							<li><code>git bisect reset</code></li>
						</ul>
						<aside class="notes">
							After doing "start, bad, good with good_commit", bisect will checked out the middle one for you.<br/>
							Run test and tell bisect this commit is good or bad.<br/>
							If bisect has enough info, it will tell you which commit is first bad commit.<br/>
							Then you should run "reset" to reset the HEAD.
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h1>Branch</h1>
					</section>
					<section>
						<h2>Create</h2>
						<ul>
							<li><code>git branch &lt;name&gt; &lt;start-point&gt;</code></li>
							<li><code>git branch -t &lt;name&gt; &lt;start-point&gt;</code></li>
							<li><code>git checkout -b &lt;name&gt; &lt;start-point&gt;</code></li>
						</ul>
						<aside class="notes">
							The -t, --track will set up config to mark the start-point branch as upstream.<br/>
							The checkout -b means creating branch and start it at start-point.
						</aside>
					</section>
					<section>
						<h2>Delete</h2>
						<ul>
							<li><code>git branch -d &lt;name&gt;</code></li>
							<li><code>git branch -D &lt;name&gt;</code></li>
							<li><code>git push origin :&lt;name&gt;</code></li>
							<li><code>git push origin --delete &lt;name&gt;</code></li>
							<li><code>git remote prune origin</code></li>
						</ul>
						<aside class="notes">
							The -d can delete the branch which is fully merged in its upstream.<br/>
							(no upstream will check the HEAD.)<br/>
							The -D will delete branch irrespective of its merged status.<br/>
							To delete the remote branch, we have to using push command.<br/>
							The ":&lt;name&gt;" means push a None to name branch.<br/>
							Or we can use --delete option.<br/>
							The remote prune can prune the local ref of remote branch.
						</aside>
					</section>
					<section>
						<h2>Other</h2>
						<ul>
							<li><code>git branch --set-upstream &lt;branch&gt; &lt;upstream&gt;</code></li>
							<li><code>git push -u &lt;upstream&gt;</code></li>
							<li><code>git branch -v</code></li>
							<li><code>git branch -vv</code></li>
							<li><code>git branch --merged</code></li>
							<li><code>git branch --no-merged</code></li>
							<li><code>git branch --contains &lt;commit&gt;</code></li>
						</ul>
						<aside class="notes">
							If we cannot find upstream, first two commands can help you.<br/>
							The -v can list the latest commit of each branch.<br/>
							The -vv will add the upstream info.<br/>
							The --merged and --no-merged will show you the branch by merged status.<br/>
							The --contains can help you find the branchs which contains one commit.
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h1>Commit</h1>
					</section>
					<section>
						<h2>Amend</h2>
						<ul>
							<li>message
								<ul>
									<li><code>git commit --amend -m &lt;message&gt;</code></li>
								</ul>
							</li>
							<li>content
								<ul>
									<li>modify</li>
									<li><code>git add</code> or <code>git rm</code></li>
									<li><code>git commit --amend</code></li>
								</ul>
							</li>
						</ul>
						<aside class="notes">
							First command will help you to modify the latest commit message.<br/>
							And the following commands will help you to modify the latest commit.
						</aside>
					</section>
					<section>
						<h2>Partially commit</h2>
						<ul>
							<li><code>git add --patch</code>, or <code>git add -i</code></li>
							<li>edit the current hunk</li>
							<li>check the partially staged part
								<ul>
									<li><code>git diff --cached</code></li>
								</ul>
							</li>
							<li>check the unstaged part
								<ul>
									<li><code>git diff</code></li>
								</ul>
							</li>
						</ul>
						<aside class="notes">
							Selecting the "edit" after the "add --patch", then remove what you don't want to commit in the editor and save.<br/>
						</aside>
					</section>
					<section>
						<h2>Rebase - squash</h2>
						<ul>
							<li><code>git rebase -i &lt;commit&gt;</code></li>
							<li>edit the list of commits in the editor
								<ul>
									<li>pick or squash</li>
								</ul>
							</li>
							<li>edit the commit message in the editor</li>
						</ul>
						<aside class="notes">
							Squash can merge many commits into one commit.<br/>
						</aside>
					</section>
					<section>
						<h2>Rebase - edit</h2>
						<ul>
							<li><code>git rebase -i &lt;commit&gt;</code></li>
							<li>edit the list of commits in the editor
								<ul>
									<li>edit</li>
								</ul>
							</li>
							<li><code>git commit --amend</code></li>
							<li><code>git rebase --continue</code></li>
						</ul>
						<aside class="notes">
							Rebase also can help you to modify the commits.<br/>
							And we can re-order the commits, too.
						</aside>
					</section>
					<section>
						<h2>Rebase - onto</h2>
						<ul>
							<li><code>git rebase --onto &lt;newbase&gt; &lt;upstream&gt; &lt;branch&gt;</code></li>
							<li>for more detail
								<ul>
									<li><code>git help rebase</code></li>
								</ul>
							</li>
						</ul>
						<aside class="notes">
							Ref: http://git-scm.com/docs/git-rebase<br/>
						</aside>
					</section>
					<section>
						<h2>Note</h2>
						<br/>
						<div>Do <span style="color: Red;">NOT</span> rebase commits that you have pushed to a public repository.</div>
						<br/>
						<div class="fragment">Or people will <span style="color: Red;">HATE</span> you!</div>
					</section>
				</section>

				<section>
					<section>
						<h1>Stash</h1>
					</section>
					<section>
						<h2>Stashing WIP work</h2>
						<ul>
							<li><code>git stash</code></li>
							<li><code>git stash list</code></li>
							<li><code>git stash apply --index &lt;stash&gt;</code></li>
							<li><code>git stash pop &lt;stash&gt;</code></li>
							<li><code>git stash branch &lt;branchname&gt; &lt;stash&gt;</code></li>
							<li><code>git stash drop &lt;stash&gt;</code></li>
						</ul>
						<aside class="notes">
							Stashing takes the dirty state of your working directory.<br/>
							After stashing, you can easily switch branches and do work elsewhere; your changes are stored on your stack.<br/>
							The "apply" command with a --index option to tell the command to try to reapply the staged changes.<br/>
							The "pop" will apply stash and drop it from stack.<br/>
							The "branch" will create a new branch, checkout the commit you were on when you stashed your work, reapplies your work there, and then drops the stash.
						</aside>
					</section>
					<section>
						<h2>Unapply</h2>
						<ul>
							<li><code>git stash show -p &lt;stash&gt; | git apply -R</code></li>
							<li><code>git config --global alias.stash-unapply '!git stash show -p | git apply -R'</code></li>
						</ul>
						<aside class="notes">
							Stashing takes the dirty state of your working directory.<br/>
							After stashing, you can easily switch branches and do work elsewhere; your changes are stored on your stack.<br/>
							The "apply" command with a --index option to tell the command to try to reapply the staged changes.
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h1>Patch</h1>
					</section>
					<section>
						<h2>Create</h2>
						<ul>
							<li><code>git diff &gt; foo.patch</code></li>
							<li><code>git format-patch -M &lt;start-point&gt;</code></li>
							<li><code>git format-patch -M -&lt;n&gt; &lt;start-point&gt;</code></li>
						</ul>
						<aside class="notes">
							We will suggest you creating patches by format-patch command.<br/>
							The -M will detect renames.<br/>
							And -<n> will prepare patches from the topmost <n> commits.
						</aside>
					</section>
					<section>
						<h2>Apply</h2>
						<ul>
							<li><code>git apply --check foo.patch</code></li>
							<li><code>git apply foo.patch</code></li>
							<li><code>git am foo.patch</code></li>
						</ul>
						<aside class="notes">
							The "apply --check" will see if the patch is applicable to the current working tree.<br/>
							For the patches which creating by "format-patch", please apply them by "am" command.
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h1>Ignore</h1>
					</section>
					<section>
						<h2>gitignore</h2>
						<ul>
							<li>{REPO}/.gitignore</li>
							<li><code>git config --global core.excludesfile '~/.gitignore'</code></li>
						</ul>
					</section>
				</section>

				<section>
					<section>
						<h1>Prompt</h1>
					</section>
					<section>
						<h2>For Bash</h2>
						<ul>
							<li>Download this <a href="https://gist.github.com/tung/409780" target="ref">script</a>.</li>
							<li>Then modify your ~/.bashrc to source this script.</li>
						</ul>
						<br/>
						<br/>
						<div class="fragment"><span style="color: Blue;">[</span><span style="color: Orange;">askeing@askeing-ubuntu</span> <span style="color: Red;">~/workspace/B2G-flash-tool</span> <span style="color: Green;">(master)</span><span style="color: Orange;">↑</span><span style="color: Blue;">]</span><span style="color: Green;">$</span>_ </div>
					</section>
				</section>

				<section>
					<section>
						<h2>Reference</h2>
						<ul>
							<li>Git Project <a href="http://git-scm.com/" target="ref">http://git-scm.com/</a></li>
							<li>Try Github <a href="https://try.github.io/" target="ref">https://try.github.io/</a></li>
							<li><a href="https://gist.github.com/tung/409780" target="ref">https://gist.github.com/tung/409780</a></li>
						</ul>
					</section>
				</section>

			</div>

		</div>

		<script src="../reveal-js/lib/js/head.min.js"></script>
		<script src="../reveal-js/js/reveal.min.js"></script>

		<script>

			Reveal.initialize({
				transition: 'linear',
				
				dependencies: [
					// Cross-browser shim that fully implements classList - https://github.com/eligrey/classList.js/
					{ src: '../reveal-js/lib/js/classList.js', condition: function() { return !document.body.classList; } },

					// Interpret Markdown in <section> elements
					{ src: '../reveal-js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '../reveal-js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },

					// Syntax highlight for <code> elements
					{ src: '../reveal-js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },

					// Zoom in and out with Alt+click
					{ src: '../reveal-js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },

					// MathJax
					{ src: '../reveal-js/plugin/math/math.js', async: true }
				]
			});

		</script>

	</body>
</html>
